#!/usr/bin/env tsx
/**
 * Script to generate TypeScript types from Zod schemas
 * Run with: npm run generate:types
 */

import fs from 'fs';
import path from 'path';
import { z } from 'zod';
import * as schemas from '../src/validation/schemas';

// Type generation utilities
function generateTypeFromZodSchema(schema: z.ZodType<any>, schemaName: string): string {
  // For complex type generation, we'll use Zod's built-in type inference
  // This is a simplified version - in production you might use a library like ts-morph
  return `export type ${schemaName} = z.infer<typeof schemas.${schemaName}>;`;
}

function generateImports(): string {
  return `import { z } from 'zod';
import * as schemas from '../../validation/schemas';

`;
}

function generateFileHeader(fileName: string): string {
  return `/**
 * Auto-generated TypeScript types from Zod schemas
 * Generated at: ${new Date().toISOString()}
 * Source: ${fileName}
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 * Edit the schema files in src/validation/schemas instead
 */

`;
}

// Schema groups for organization
const schemaGroups = {
  common: [
    'idSchema',
    'timestampsSchema',
    'softDeleteSchema',
    'addressSchema',
    'coordinatesSchema',
    'fileUploadSchema',
    'tagSchema',
    'noteSchema',
    'baseSortSchema',
    'searchSchema',
    'batchIdsSchema',
    'batchOperationSchema'
  ],
  user: [
    'userProfileSchema',
    'createUserSchema',
    'updateUserSchema',
    'userPreferencesSchema',
    'userFilterSchema',
    'userStatsSchema',
    'bulkUserImportSchema'
  ],
  organization: [
    'businessHoursSchema',
    'organizationSettingsSchema',
    'createOrganizationSchema',
    'updateOrganizationSchema',
    'amenitySchema',
    'staffAssignmentSchema',
    'locationSchema',
    'organizationStatsSchema'
  ],
  membership: [
    'membershipTypeSchema',
    'createMembershipSchema',
    'updateMembershipSchema',
    'pauseMembershipSchema',
    'cancelMembershipSchema',
    'transferMembershipSchema',
    'membershipAddonSchema',
    'membershipUsageSchema',
    'membershipFilterSchema'
  ],
  event: [
    'recurrenceSchema',
    'createEventSchema',
    'updateEventSchema',
    'cancelEventSchema',
    'createBookingSchema',
    'updateBookingSchema',
    'attendanceSchema',
    'eventFilterSchema',
    'waitlistSchema'
  ],
  workout: [
    'exerciseSchema',
    'workoutSetSchema',
    'workoutExerciseSchema',
    'workoutTemplateSchema',
    'workoutSessionSchema',
    'performedSetSchema',
    'performedExerciseSchema',
    'workoutProgressSchema',
    'workoutPlanSchema',
    'userWorkoutPlanSchema'
  ],
  notification: [
    'notificationSchema',
    'sendNotificationSchema',
    'notificationTemplateSchema',
    'updateNotificationPreferencesSchema',
    'notificationStatusSchema',
    'inAppNotificationSchema',
    'markNotificationsReadSchema',
    'notificationAnalyticsSchema'
  ]
};

// Generate enum types
const enumTypes = {
  common: [
    'userStatusEnum',
    'membershipStatusEnum',
    'eventStatusEnum',
    'bookingStatusEnum',
    'roleEnum',
    'sortOrderSchema'
  ],
  organization: [
    'organizationTypeEnum'
  ],
  event: [
    'eventTypeEnum'
  ],
  workout: [
    'muscleGroupEnum',
    'exerciseCategoryEnum',
    'equipmentEnum'
  ],
  notification: [
    'notificationTypeEnum',
    'notificationChannelEnum',
    'notificationPriorityEnum'
  ]
};

async function generateTypes() {
  const outputDir = path.join(__dirname, '../src/types/generated');
  
  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate type files for each group
  for (const [groupName, schemaNames] of Object.entries(schemaGroups)) {
    const fileName = `${groupName}.types.ts`;
    const filePath = path.join(outputDir, fileName);
    
    let content = generateFileHeader(fileName);
    content += generateImports();
    
    // Add schema type exports
    for (const schemaName of schemaNames) {
      const typeName = schemaName.charAt(0).toUpperCase() + schemaName.slice(1).replace(/Schema$/, '');
      content += `export type ${typeName} = z.infer<typeof schemas.${schemaName}>;\n`;
    }
    
    // Add enum type exports
    if (enumTypes[groupName as keyof typeof enumTypes]) {
      content += '\n// Enum types\n';
      for (const enumName of enumTypes[groupName as keyof typeof enumTypes]) {
        const typeName = enumName.charAt(0).toUpperCase() + enumName.slice(1).replace(/Enum$|Schema$/, '');
        content += `export type ${typeName} = z.infer<typeof schemas.${enumName}>;\n`;
      }
    }
    
    // Write file
    fs.writeFileSync(filePath, content);
    console.log(`✓ Generated ${fileName}`);
  }
  
  // Generate a barrel export file
  const indexPath = path.join(outputDir, 'index.ts');
  let indexContent = generateFileHeader('index.ts');
  indexContent += `export * from './common.types';\n`;
  indexContent += `export * from './user.types';\n`;
  indexContent += `export * from './organization.types';\n`;
  indexContent += `export * from './membership.types';\n`;
  indexContent += `export * from './event.types';\n`;
  indexContent += `export * from './workout.types';\n`;
  indexContent += `export * from './notification.types';\n`;
  
  fs.writeFileSync(indexPath, indexContent);
  console.log('✓ Generated index.ts');
  
  console.log('\n✅ Type generation complete!');
}

// Run the script
generateTypes().catch(error => {
  console.error('Error generating types:', error);
  process.exit(1);
});